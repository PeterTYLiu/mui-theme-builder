import { rgbToHex, type ThemeOptions } from "@mui/material";
import { toast } from "sonner";

export const toStandardHex = (input: string, fallback: string = "#000000"): string => {
  if (input.startsWith("rgb")) return toStandardHex(rgbToHex(input));

  if (input.match(/^#?([a-f0-9]{3}|[a-f0-9]{4}|[a-f0-9]{6}|[a-f0-9]{8})$/)) {
    // Normalize
    input = input.toLowerCase();
    if (input.startsWith("#")) input = input.substring(1);
    // Double if shorthand
    if (input.length === 3 || input.length === 4) {
      input = input.split("").reduce((prev, curr) => `${prev}${curr}${curr}`, "");
    }
    // Return
    if (input.length === 6) return `#${input}`;
    // Account for unnecessary #eeeaaaff
    return input.endsWith("ff") ? `#${input.substring(0, 6)}` : `#${input}`;
  }

  return fallback;
};

export const intToHex = (number: number): string => {
  const hexString = number.toString(16);
  return hexString.padStart(2, "0");
};

export const decimalToHex = (number: number): string => {
  const int = Math.round(number * 255);
  return intToHex(int);
};

// Generated by Claude
export const deleteKeys = (input: ThemeOptions, keys: Array<string>): ThemeOptions => {
  // Create a deep clone of the input
  const result = structuredClone(input);

  // Helper function to check if an object is empty
  const isEmpty = (obj: any): boolean => {
    if (obj === null || obj === undefined) return true;
    if (typeof obj !== "object") return false;
    return Object.keys(obj).length === 0;
  };

  // Helper function to recursively delete and clean up
  const deleteAtPath = (obj: Record<any, any>, pathKeys: string[]): boolean => {
    // Base case: if no keys left, shouldn't happen
    if (pathKeys.length === 0) return false;

    // If we're at the last key, delete it
    if (pathKeys.length === 1) {
      const key = pathKeys[0];
      if (key in obj) {
        delete obj[key];
        return true;
      }
      return false;
    }

    // Otherwise, recurse deeper
    const [currentKey, ...remainingKeys] = pathKeys;

    // If the current key doesn't exist or isn't an object, we can't continue
    if (!(currentKey in obj) || typeof obj[currentKey] !== "object" || obj[currentKey] === null) {
      return false;
    }

    // Recursively delete in the nested object
    const deleted = deleteAtPath(obj[currentKey], remainingKeys);

    // If deletion happened and the nested object is now empty, remove it
    if (deleted && isEmpty(obj[currentKey])) {
      delete obj[currentKey];
    }

    return deleted;
  };

  // Perform the deletion
  deleteAtPath(result, keys);

  return result;
};

export async function saveObjectToClipboard(data: any): Promise<void> {
  try {
    const jsonString = JSON.stringify(data, null, 2);
    await navigator.clipboard.writeText(jsonString);
    toast.success("Theme options copied to clipboard");
  } catch (error) {
    toast.error("Failed to copy theme to clipboard");
    console.error(error);
    throw error;
  }
}
